## mmap

mmap是一种内存映射方法：将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟空间地址中的一一映射关系。实现这种映射关系之后，进程就可以采用指针的方式读写操作这一段内存，而系统会 **回写脏页** 到对应的文件磁盘上，简而言之就是对文件的操作不再调用read、write等系统调用。内核对这段区域的修改也可以直接反映用户空间，从而可以实现不同进程间的文件共享。

## mmap高效原因

### 普通的文件操作流程如下：

- 进程发起读文件的请求
- 内核通过查找进程文件符表，定位到内核已经打开的文件集上的文件信息
- 如果没有发起缺页中断，然后把页面加载到 **内核态 **的缓存上
- 将  **内核态 的缓存页面** 转存到**用户态** (就是ram)中

### 用mmap的流程如下：

**（一) 启动映射进程，并在虚拟地址空间中为映射创建虚拟映射区域**

1. 进程在用户空间调用库函数mmap。
2. 在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址
3. 在此虚拟区分配一个vm_area_struct结构，并且对这个结构进行初始化
4. 将行的vm_area_struct结构插入进程的虚拟地址区域链表。

**(二) 调用内核空间的系统调用函数mmap，实现文件物理映射**

5. 为映射分配了行的虚拟地址区域之后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已经打开文件集”中该文件的文件结构体，每个文件结构体维护着和这个已经打开的文件相关的各项信息
6. 通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap
7. 内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址
8. 通过remap_pfn_range函数建立页表，实现文件地址和虚拟地址的映射关系，此时，这片虚拟地址并没有任何数据关联到主存中

**(三) 进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内容的拷贝**

>前面的操作主要是对虚拟区间和物理空间的映射

9. 进程的读或者写操作访问虚拟地址空间这一段映射空间，通过查询页表，发现这一段地址并不在物理页面上（ram）中，就是说数据还没有从文件拷贝到ram中，因此会引发缺页异常。
10. 内核发起请求调页过程。
11. 调页过程先在(swap cache)中寻找，如果没有，就调用nopage函数把所缺的页从磁盘装入到主存中。
12. 之后进程对这片主存进行读写操作的时候，一段时间后这个数据会被操作系统回写到文件中（依赖os）

> 修改过的脏页不会立刻更新到文件中，可以调用msync()来强制同步，这样缩写的内容就能立刻保存到文件里面了

### 总结

总而言之，常规操作文件需要从磁盘到页面缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。mmap的关键点是省去了文件到内核的缓存页面这一步操作。



## mmap优点总结

1. 跨过了页缓存，减少了数据的拷贝次数，提高了文件读取效率。
2. 提供进程间共享内存以及相互通信的方式。不管是父子进程还是无亲缘的进程，都可以通过对一个文件映射来达到修改文件的目的。
   1. 比如A和B进程都映射了C区域，如果A第一次通过缺页从磁盘读取了文件页到内存中；但是如果B再读C的时候，虽然也会产生缺页异常，但是不用再次读取了，直接使用在内存中的页面。
3. 可以用于实现高效的大规模数据传输。内存空间不足，是至于大数据操作的一个反面，解决方案往往是借助硬盘空间协助操作，这种时候mmap是很好的解决办法。